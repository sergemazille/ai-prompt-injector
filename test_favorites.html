<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Test Favorites System</title>
  <style>
    .test-result { margin: 10px 0; padding: 5px; border-left: 3px solid #ccc; }
    .pass { border-color: green; background: #f0f8f0; }
    .fail { border-color: red; background: #f8f0f0; }
  </style>
</head>
<body>
  <h1>Test Favorites System</h1>
  <div id="results"></div>

  <script>
    // Mock browser.storage.local
    window.browser = {
      storage: {
        local: {
          data: {},
          get: function(key) {
            return Promise.resolve({ [key]: this.data[key] });
          },
          set: function(obj) {
            Object.assign(this.data, obj);
            return Promise.resolve();
          }
        }
      }
    };

    // Load the storage class (copy the relevant parts)
    class PromptStorage {
      constructor() {
        this.storageKey = 'prompts';
      }

      generateId() {
        return 'prompt_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
      }

      extractTimestampFromId(id) {
        // Extract timestamp from ID format: "prompt_TIMESTAMP_random"
        const match = id && id.match && id.match(/^prompt_(\d+)_/);
        return match ? parseInt(match[1]) : Date.now();
      }

      async getPrompts() {
        try {
          const result = await browser.storage.local.get(this.storageKey);
          const raw = result[this.storageKey];
          let prompts = [];
          
          if (Array.isArray(raw)) {
            prompts = raw;
          } else if (raw && typeof raw === 'object' && Array.isArray(raw.prompts)) {
            prompts = raw.prompts;
            await browser.storage.local.set({ [this.storageKey]: prompts });
          } else if (raw !== undefined) {
            await browser.storage.local.set({ [this.storageKey]: [] });
            return [];
          }
          
          // Ensure all prompts have favorite and createdAt properties (backward compatibility)
          prompts = prompts.map(prompt => ({
            ...prompt,
            favorite: prompt.favorite === true, // Ensure it's a boolean, default to false
            createdAt: prompt.createdAt || this.extractTimestampFromId(prompt.id) // Extract from ID if missing
          }));
          
          // Sort by favorites first, then by creation date (newest first)
          prompts.sort((a, b) => {
            // Primary sort: favorites first
            if (a.favorite !== b.favorite) {
              return a.favorite ? -1 : 1;
            }
            // Secondary sort: newest first within same favorite status
            return (b.createdAt || 0) - (a.createdAt || 0);
          });
          
          return prompts;
        } catch (error) {
          console.error('Error getting prompts:', error);
          return [];
        }
      }

      async toggleFavorite(promptId) {
        try {
          const prompts = await this.getPrompts();
          const promptIndex = prompts.findIndex(p => p.id === promptId);
          
          if (promptIndex === -1) {
            throw new Error('Prompt not found');
          }
          
          prompts[promptIndex].favorite = !prompts[promptIndex].favorite;
          await browser.storage.local.set({ [this.storageKey]: prompts });
          
          return prompts[promptIndex].favorite;
        } catch (error) {
          console.error('Error toggling favorite:', error);
          throw error;
        }
      }
    }

    // Run tests
    async function runTests() {
      const storage = new PromptStorage();
      const results = document.getElementById('results');
      
      function addResult(test, passed, details = '') {
        const div = document.createElement('div');
        div.className = `test-result ${passed ? 'pass' : 'fail'}`;
        div.innerHTML = `<strong>${test}:</strong> ${passed ? 'PASS' : 'FAIL'} ${details}`;
        results.appendChild(div);
      }

      try {
        // Test 1: Initial state
        let prompts = await storage.getPrompts();
        addResult('Initial empty state', prompts.length === 0);

        // Test 2: Add test data with timestamps for chronological sorting
        const now = Date.now();
        await browser.storage.local.set({
          prompts: [
            { id: 'prompt_' + (now - 3000) + '_old', label: 'Oldest', template: 'Content 1', tags: [], favorite: false, createdAt: now - 3000 },
            { id: 'prompt_' + (now - 2000) + '_mid', label: 'Middle', template: 'Content 2', tags: [], favorite: true, createdAt: now - 2000 },
            { id: 'prompt_' + (now - 1000) + '_new', label: 'Newest', template: 'Content 3', tags: [], favorite: false, createdAt: now - 1000 }
          ]
        });

        prompts = await storage.getPrompts();
        addResult('Data loaded correctly', prompts.length === 3);

        // Test 3: Favorites first, then chronological within groups
        addResult('Favorite prompt first', prompts[0].favorite === true && prompts[0].label === 'Middle');
        addResult('Non-favorites by creation date', prompts[1].label === 'Newest' && prompts[2].label === 'Oldest');

        // Test 4: Timestamp extraction from ID (backward compatibility)
        await browser.storage.local.set({
          prompts: [
            { id: 'prompt_1500000000000_abc', label: 'Legacy', template: 'Content', tags: [] }
          ]
        });
        
        prompts = await storage.getPrompts();
        const legacyPrompt = prompts.find(p => p.label === 'Legacy');
        addResult('Timestamp extracted from ID', legacyPrompt && legacyPrompt.createdAt === 1500000000000);

        // Test 5: Multiple favorites sorted chronologically  
        await browser.storage.local.set({
          prompts: [
            { id: '1', label: 'Fav Old', template: 'Content', tags: [], favorite: true, createdAt: now - 5000 },
            { id: '2', label: 'Fav New', template: 'Content', tags: [], favorite: true, createdAt: now - 1000 }
          ]
        });

        prompts = await storage.getPrompts();
        addResult('Multiple favorites sorted chronologically', 
          prompts[0].label === 'Fav New' && prompts[1].label === 'Fav Old');

        // Test 6: Toggle favorite preserves chronological order
        const oldestId = prompts.find(p => p.label === 'Fav Old').id;
        await storage.toggleFavorite(oldestId);
        
        prompts = await storage.getPrompts();
        const nonFavorites = prompts.filter(p => !p.favorite);
        addResult('Chronological order preserved after toggle', 
          nonFavorites.length > 0 && nonFavorites[0].label === 'Fav Old');

        // Test 7: Specific test for unfavorite re-ordering behavior
        const testTime = Date.now();
        await browser.storage.local.set({
          prompts: [
            { id: 'fav1', label: 'Favorite 1', template: 'Content', tags: [], favorite: true, createdAt: testTime - 4000 },
            { id: 'fav2', label: 'Favorite 2', template: 'Content', tags: [], favorite: true, createdAt: testTime - 3000 },
            { id: 'normal1', label: 'Normal Old', template: 'Content', tags: [], favorite: false, createdAt: testTime - 2000 },
            { id: 'normal2', label: 'Normal New', template: 'Content', tags: [], favorite: false, createdAt: testTime - 1000 }
          ]
        });

        // Get initial order
        prompts = await storage.getPrompts();
        addResult('Initial setup correct', 
          prompts[0].label === 'Favorite 2' && 
          prompts[1].label === 'Favorite 1' && 
          prompts[2].label === 'Normal New' && 
          prompts[3].label === 'Normal Old'
        );

        // Remove Favorite 2 from favorites (newest favorite)
        await storage.toggleFavorite('fav2');
        prompts = await storage.getPrompts();
        
        // Verify new order: Fav1 first, then Normal New, then Fav2 (now unfavorited), then Normal Old
        const expectedOrder = ['Favorite 1', 'Normal New', 'Favorite 2', 'Normal Old'];
        const actualOrder = prompts.map(p => p.label);
        const correctOrder = JSON.stringify(expectedOrder) === JSON.stringify(actualOrder);
        
        addResult('Unfavorited prompt correctly repositioned by creation date', correctOrder, 
          `Expected: ${expectedOrder.join(' → ')}, Got: ${actualOrder.join(' → ')}`);

        // Test edge case: Remove oldest favorite
        await browser.storage.local.set({
          prompts: [
            { id: 'fav_old', label: 'Fav Old', template: 'Content', tags: [], favorite: true, createdAt: testTime - 5000 },
            { id: 'fav_new', label: 'Fav New', template: 'Content', tags: [], favorite: true, createdAt: testTime - 1000 },
            { id: 'normal_mid', label: 'Normal Mid', template: 'Content', tags: [], favorite: false, createdAt: testTime - 3000 }
          ]
        });

        // Remove oldest favorite
        await storage.toggleFavorite('fav_old');
        prompts = await storage.getPrompts();
        
        // Expected: Fav New, Normal Mid, Fav Old (now at bottom since it's oldest)
        const edgeExpected = ['Fav New', 'Normal Mid', 'Fav Old'];
        const edgeActual = prompts.map(p => p.label);
        const edgeCorrect = JSON.stringify(edgeExpected) === JSON.stringify(edgeActual);
        
        addResult('Oldest unfavorited prompt goes to correct chronological position', edgeCorrect,
          `Expected: ${edgeExpected.join(' → ')}, Got: ${edgeActual.join(' → ')}`);

        addResult('All unfavorite re-ordering tests completed', true, '✅');

      } catch (error) {
        addResult('Test execution', false, error.message);
      }
    }

    // Run tests when page loads
    window.onload = runTests;
  </script>
</body>
</html>